<html>
    <head>
        <script src="keyItemList.js"></script>
        <title>DS1-Auto-Item-Tracker-MAIN</title>
        <meta charset="utf-8"/>
    </head>
<style>
    .editProp {
        color: orangered;
        min-width: 5rem;
        display: inline-block;
        font-family: monospace;
    }
    
    .fileInfo {
        font-size: 1rem;
        position: absolute;
        color: #141450;
        top: 0rem;
        right: 1rem;
        width: 30%;
    }

    .dropZone {
        background: lightgray;
        /* width: 50rem; */
        /* height: 6rem; */
        margin-bottom: 2rem;
        font-size: 8rem;
        font-weight: 600;
        text-align: center;
        user-select: none;
        border: dotted gray 0.2rem;
        position: relative;
        color: #565252
    }

    .dropBg, .dropBBg {
        color: #131515;
        font-size: 0.8rem;
        position: absolute;
        top: 0.5rem;
        right: 50%;
        transform: translateX(50%);
    }

    span.dropBBg {
        /* color: #7d7777; */
        bottom: 0.5rem;
        top: inherit;
    }

    .ib {
        display: inline-block;
    }

    body {
        background-color: snow;
    }

    body div {
        margin: 0.25rem;
    }

    #infoBox {
        white-space: pre;
    }

    #infoBox table {
        border-collapse: collapse;
    }
    
    #infoBox table tbody tr:nth-child(odd) {
        background-color: #e2e2e2;
    }

    #infoBox table td {
        border: 2px solid #333A;
        padding: .2rem .5rem;
    }

    #infoState {
        font-size: 1.1rem;
        font-weight: bold;
    }


    .inlineGroup {
        display: inline-block;
        background-color: orange;
        padding: .2em;
        font-family: "Candara";
    }

    #customBar {
        position: relative;
        display: flex;
        user-select: none;
    }

    #customRemove {
        display: inline-block;
        background-color: lightcoral;
        padding: 0.2em 1em;
        margin: 0;
        cursor: not-allowed
    }

    #customRemove.dragover {
        background-color: red;
    }

    #customAdd {
        background-color: #96c2e5;
        color: black;
        cursor: pointer;
        border: none;
        padding: 0.5em 1em;
        font-weight: bold;
        user-select: none;
    }
    #customAdd.open {
        background-color: blue;
        color: white;
    }
    #customAdd:hover:not(.open) {
        background-color: lightblue;
    }

    #customLayoutLock {
        background-color: snow;
        font-size: 1.5em;
        cursor: pointer;
        user-select: none;
        /* box-sizing: content-box; */
        /* transition: font-size ease-out 0.2s; */
        padding: 0 0.2em;
    }
    #customLayoutLock::after {
        content: "üîí"
    }
    #customLayoutLock.unlocked::after {
        content: "üîì"
    }
    #customLayoutLock:hover {
        font-size: 1.6em;
        /* transition: font-size ease-out 0.2s; */
    }

    #customTooltip {
        padding: 0.5em 1em;
        color: black;
        background-color: #eb9b78;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
    }
    #customTooltip.open {
        background-color: coral;
    }
    #customTooltip:hover:not(.open) {
        background-color: #ffc4ae;
    }

    #itemListContainer {
        background: slategray;
        padding: 0.4em 0.2em;
        position: absolute;
        left: 100%;
        width: 30em;
        z-index: 1;
        display:none
    }
    #customAdd.open ~ #itemListContainer.open {
        display: block;
    }
    #itemListContainer input {
        background-color: gray;
        border-style: dashed;
        border-color: #575b5e;
    }

    #itemList {
        grid: repeat(2, fit-content(55px)) / auto-flow;
        display: grid;
        gap: 5px;
        overflow-x: scroll;
        background-color: #41464c;
        padding: 0.5em 0;
        justify-content: start;
    }

    #itemList .itemImage {
        width: 55px;
        height: 55px;

    }

    .itemGrid {
        display: grid;
        /* grid-template-columns: repeat(3, 100px); */
        gap: 10px;
        /* grid-auto-rows: minmax(50px, auto); */
    }

    .itemImage {
        filter: drop-shadow(5px 5px 4px #111);
        width: 90px;
        height: 90px;
        position: relative;
        object-fit: contain;
        margin: 0;
        cursor: grab;
        user-select: none;
    }

    .itemImage.transparent {
        opacity: 0.5;
    }

    .itemImage.blank {
        filter: none;
        cursor: default;
    }

    .itemImage.dragover {
        background-color: lightblue;
        cursor: move;
    }

    .itemImage.dragging {
        opacity: 0.2;
        cursor: grabbing;
    }

    .itemImage img {
        object-fit: contain;
    }

    .itemImage.hideImg {
        display: none
    }

    /* .itemImage[data-tooltip]::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 10%;
        top: 20%;
        z-index: 100;
        font-size: 14px;
        color: white;
    } */

    .itemTooltip {
        position: absolute;
        z-index: 100;
        font-size: 14px;
        color: black;
        background-color: darkgray;
        padding: 0.5em 0.2em;
        user-select: none;
        white-space: pre;
        pointer-events: none;
        display: none;
    }

    .itemTooltip.show {
        display: block;
    }

    .browserSourceBtn {
        /* padding: 0.2rem 0.6rem; */
        padding: 0;
        color: black;
        background: #d8d8d838;
        border: 2px solid #46415f;
        font-weight: bold;
        text-align: center;
        cursor: pointer;
        /* user-select: none; */
        position: relative;
        width: 100%;
        font-size: 0.9rem;
        height: 2rem;
        transition: border 0.2s, background 0.2s;
        /* border-radius: 0 0 15% 15%; */
    }

    .browserSourceBtn:hover {
        background: #94bfff38;
        border: 2px solid #3334e2;
    }

    /* .hangLeft {
        background-color: #000C;
        font-family: monospace;
        color: snow;
        text-shadow: 2px 1px black;
        border-right: 2px solid black;
        margin: 0;
        padding: 0.1rem 0.3rem;
        font-size: 1.2rem;
        cursor: pointer;
    } 
    */

    .browserSourceBtn:disabled + .hangLeft {
        cursor: not-allowed;
    }

    .browserSourceBtn:disabled {
        color: #504c4c;
        --dark-bg: #EEE3;
        --light-bg: #3033;
        background: repeating-linear-gradient(135deg, var(--light-bg), var(--light-bg) 10px, var(--dark-bg) 10px, var(--dark-bg) 20px, var(--light-bg) 20px);
        user-select: none;
        cursor: not-allowed;
    }

    .browserSourceBtn::after {
        content: 'Copied!';
        background-color: black;
        color: white;
        position: absolute;
        top: 0;
        transform: translate(-50%, -130%);
        left: 50%;
        padding: 0.2rem;
        opacity: 0;
        transition: opacity 2s; 
    }


    .browserSourceBtn::before { /* This is the tiny triangle btw*/
        content: '';
        /* background-color: red; */
        position: absolute;
        top: 0;
        left: 50%;
        transform: translate(-50%, -100%);
        width: 0;
        height: 0;
        border-left: .5rem solid transparent;
        border-right: .5rem solid transparent;
        border-top: .45rem solid black;
        opacity: 0;
        transition: opacity 2s;
    }

    .browserSourceBtn:active::after,
    .browserSourceBtn:active::before {
        opacity: 1;
        transition: opacity 0s; 
        content: 'Copied!';
    }

    .autoCircle {
        background: red;
        border-radius: 50% 50%;
    }

    .debugDisclaimer {
        transform: translateX(-140px) rotate(-20deg);
        position: absolute;
        font-size: 180px;
        writing-mode: vertical-rl;
        opacity: 30%;
        color: red;
        user-select: none;
    }

    .title {
        font-size: 1.7rem;
        font-weight: bold;
        margin: 0;
        font-family: system-ui;
        color: #3e4042;
    }

    .title span {
        font-size: 0.7rem;
        font-weight: bold;
    }

    .step {
        /* padding-top: 1rem; */
        font-size: 1.1rem;
        border-top: 1px solid #3336;
        padding: 1rem 0;
        overflow: hidden;
        max-height: 5rem;
        margin: 0
    }

    .step .step_num {
        font-size: 1.5rem;
        color: black;
        font-weight: bold;
        
        border: 3px solid black;
        padding: 3px;
        border-radius: 50%;
        display: inline-block;
        width: 1.5rem;
        height: 1.5rem;
        line-height: 1.5rem;
        text-align: center;
    }

    .save_loc {
        background-color: #eaeaea;
        font-family: system-ui;
        /* color: #25124a; */
        font-weight: 600;
        padding: 0.2rem;
    }

    .bold {
        font-weight: bold;
    }

    #steps.min .step:first-child,
    #steps.min .step:nth-child(2) {
        max-height: 0px;
        margin: 0px;
        padding: 0px;
        transition: max-height 1s, margin 1s, padding 1s;
    }

    .msgBox {
        display: none;
        background-color: gray;
        padding: 0.25em;
        font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        white-space: pre;
    }

    .msgBox.show {
        display: flex;
    }

    .msgBox.error {
        background-color: #f14d4d;
    }

    .msgBox.warning {
        background-color: #f1f150;
    }

    .msgBox button {
        justify-self: flex-end;
    }

    .msgBox p {
        flex: 1;
        margin: 0;
        padding: 0 2em;
    }

</style>

<body>
    <div class="itemTooltip">
        Random test text here
    </div>
    <div class="msgBox">
        <p>Message</p>
        <button>x</button>
    </div>
    <div style="display: flex">
        <div class="debugContainer">
        <div id="customBar">
            <span id="customLayoutLock" class="unlocked" data-tooltip="Lock the layout to prevent add/removing.
Then you can use this as a browser source instead"></span>
            <button id="customLayout" disabled data-tooltip="(NOT ENABLED) Change layout options">Layout</button>
            <span class="inlineGroup" data-tooltip="Choose a preset. All changes are auto-saved.">
                <span>Choose Preset:</span>
                <select id="customPreset">
                    <option value="basic">Basic Only</option>
                    <option value="locksInOrder">Locks In Order*</option>
                    <option value="allKey">All Key Items</option>
                    <option value="essential">Essential</option>
                    <option value="custom" disabled>Custom</option>
                </select>
            </span>
            <span id="customRemove" data-tooltip="Items dragged here are deleted">Drag here to RemoveüóëÔ∏è</span>
            <span id="customAdd" data-tooltip="Click to open a list of items to add">Add</span>
            <span id="customTooltip" data-tooltip="When pressed, tooltips are shown on the items">?</span>
            <div id="itemListContainer">
                <div>
                    <span>üîç</span>
                    <input type="search">
                </div>  
                <div id="itemList">
                </div>

            </div>
        </div>
        <div class="itemGrid">
            <p class="debugDisclaimer">DEBUG</p>
        </div>
        </div>
        
        <div>
            <div class="dropZone">+
                <span class="dropBg">Drop save file .sl2 here</span>
                <span class="dropBBg">Or double click and select a file</span>
                <div class="fileInfo">
                    <p>File name: <span id="fileName" class="editProp"></span></p> 
                    <p>Updated: <span id="lastUpdated" class="editProp"></span></p>
                </div>
            </div>

            <p class="title"> DS1:PTE / DS1R Auto-Tracker<span class="version">1.2</span></p>
            <div id="steps">
            <p class="step">
                <span class="step_num">1</span> Find your DS1 <span class="bold">save file</span> at <br/>
                <span class="save_loc">Documents \ NBGI \ Dark Souls &ltRemastered&gt \ &ltDRAKS0005&gt.sl2</span><br/>

            </p>
            <p class="step">
                <span class="step_num">2</span>
                <span class="bold">Drag & Drop</span> your save file to the gray zone <br/>
                <span class="bold">OR Double-click</span> the gray zone and select your save file.
            </p>
            <p class="step" style="position:relative">
                <span class="step_num">3</span>
                <span class="bold">Click</span> and Copy this link to use as a <span class="bold">browser source</span> <br/>
                <div style="display:flex" id="browserHolder">
                    <button class="browserSourceBtn" disabled>Waiting...</button>
                    <!-- <button class="hangLeft" disabled>Copy</button> -->
                </div>
            </p>
            <p class="step">
                <span class="step_num">4</span>
                Keep this page <span class="bold">open</span> and ENJOY!
            </p>
            <p>Debug info: <span id="infoState"></span></p>
            <p id="infoBox"></p>
            
            </div>
        </div>
    </div>
</body>

<script>
    let fileHandle;
    let actualFile;
    let filePollTimeout = null;
    const filePollTime = 2000;
    let DSPTE_ReadMode = false;

    let players = null;
    let oldPlayers = null;

    // Request ID & save in local storage
    const baseUrl = (window.location.protocol != 'file:') ? 
        'https://ds1.leagueautotimer.dev' : 'http://localhost:8081'
    const currHostname = window.location.origin
    const displayUrl = '/display.html'
    const keepAliveTimeout = 1000 * 10 * 1; // default to 15s keep alive
    let fetchIDPromise = null
    let spkID = null // id given by server to talk to
    let earID = null // id given by server to listen on
    let keepAliveTs = Date.now()
    // TODO: Change timing of reserve & keep-alive to after file init 
    let keepAliveInterval = null

    
    // Send key
    async function setUpSpeaker () {
        console.log(`Sending key ${window.localStorage.getItem('DS1RandoMic_ID')}`)

        fetchIDPromise = fetch(`${baseUrl}/pickMic`, {method: 'POST', mode: 'cors', cache: 'no-cache', 
            headers: {'Content-Type': 'text/plain'},
            body: window.localStorage.getItem('DS1RandoMic_ID')}
        ).then(async resp => {
            
            let IDPromise = null
            if (resp.status == 201) {
                IDPromise = resp.text().then(text => {
                    let sp_text = text.split(':')
                    window.localStorage.setItem('DS1RandoMic_ID', sp_text[0])
                    window.localStorage.setItem('DS1RandoMic_Spk', sp_text[1])
                    console.log(`Updated keys to ${text}`)
                })
            } else if (resp.status == 204) {
                console.log('Allowed to use key')
                IDPromise = Promise.resolve(true)
            } else {
                infoBox.textContent = `Got an error response from server: ${resp}`
                return
            }

            // console.log(IDPromise)

            await IDPromise;
            // resolve the button/auto stuff, and set values
            spkID = parseInt(window.localStorage.getItem('DS1RandoMic_ID'))
            earID = parseInt(window.localStorage.getItem('DS1RandoMic_Spk'))
            console.log('Verified server conn')
            copyDisplayLink.removeAttribute('disabled')
            copyDisplayLink.textContent = `${currHostname}${displayUrl}?ear=${earID}`

            keepAliveInterval =  setInterval( () => {
                if (spkID && keepAliveTs < Date.now() - keepAliveTimeout ) {
                    resp = fetch(`${baseUrl}/speakMic`, 
                        {method: 'POST', mode: 'cors', cache: 'no-cache', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({'spkID': spkID, 'keep-alive': true})}
                    ).then(resp => {
                        if (resp.status == 401) {
                            console.log('Server rejected spkID. Refreshing')
                            setUpSpeaker() // TODO: Review setup the speaker and file read
                            readBND4File(actualFile)
                        }
                    })
                    keepAliveTs = Date.now()
                    // console.log("Exec keep-alive")
                }
            }, keepAliveTimeout)

            // send layout on connect
            sendLayoutChange()

        }, err => { // else something went wrong
            infoBox.textContent = "Unable to connect to server."
            console.log(err)
            console.error('This cannot continue (cause server not available)')
            displayMsgToUser('Server is not available.', 'error')
        })
    }

    let trackedPlayer = null // this is a diff with player obj

    // on-screen elements
    const copyDisplayLink = document.querySelector('.browserSourceBtn');
    copyDisplayLink.addEventListener('click', event => {
        // copy url to clipboard
        navigator.clipboard.writeText(`${currHostname}${displayUrl}?ear=${earID}`)
    })

    const fileName = document.querySelector('#fileName')
    const fileLastUpdated = document.querySelector('#lastUpdated')
    const infoBox = document.querySelector('#infoBox')
    const infoState = document.querySelector('#infoState')
    const itemGridDiv = document.querySelector('.itemGrid')
    const itemListDiv = document.querySelector('#itemList')

    // Item Grid presets
    const essentialsGrid = [	[null, "Bed of Chaos Lord Soul", null],
		                        [null, "Lordvessel", null],
		                        ["Seath Bequeathed Lord Soul Shard", "Nito Lord Soul", "Four Kings Bequeathed Lord Soul Shard"],
	]

    const locksInOrderGrid = [
    [
        "Undead Asylum F2 West Key",
        "Key to Depths",
        "Peculiar Doll",
        "Annex Key"
    ],
    [
        "Lordvessel",
        "Key to the Seal",
        "Broken Pendant",
        "Crest Key"
    ],
    [
        "Light Source",
        "Covenant of Artorias",
        "Archive Tower Giant Cell Key",
        "Orange Charred Ring"
    ],
    [
        "Nito Lord Soul",
        "Four Kings Bequeathed Lord Soul Shard",
        "Seath Bequeathed Lord Soul Shard",
        "Bed of Chaos Lord Soul"
    ]
]

    const pattyItemGrid = [
        ["Lordvessel", "Orange Charred Ring", "Seath Bequeathed Lord Soul Shard"],
        ["Covenant of Artorias", "Key to Depths",       "Four Kings Bequeathed Lord Soul Shard"],
        ["Peculiar Doll",       "Annex Key",           "Nito Lord Soul"],
        ["Broken Pendant",     "Light Source",         "Bed of Chaos Lord Soul"],
        ["Key to the Seal",  "Darkmoon Seance Ring",  "Basement Key"],
    ]

    const AllTheKeyItems = [
        ["Key to Depths", "Annex Key", "Dungeon Cell Key", "Cage Key", "Key to New Londo Ruins", null ],
        ["Basement Key",  "Big Pilgrim's Key", "Key to the Seal",  "Crest Key", "Mystery Key", null],
        ["Residence Key", "Sewer Chamber Key", "Undead Asylum F2 East Key", "Watchtower Basement Key", "Key to the Seal", null],
        ["Covenant of Artorias", "Crest of Artorias",  "Darkmoon Seance Ring", "Orange Charred Ring", "Peculiar Doll", "Broken Pendant"],
        ["Lordvessel", "Seath Bequeathed Lord Soul Shard", "Four Kings Bequeathed Lord Soul Shard", "Nito Lord Soul", "Bed of Chaos Lord Soul", null],
    ]

    const gridImgLink = {} // Used to set/unset the items based on save-file
    let dragTarget = null   // save drag-start target for swaps/spawns
    const currGridItems = []

    // Remove icon
    const removeItemDiv = document.getElementById('customRemove')
    removeItemDiv.addEventListener('dragover', (ev) => {
        if (!dragTarget || dragTarget.parentElement != itemGridDiv) {
            return
        }
        ev.preventDefault()
        ev.dataTransfer.dropEffect = 'move'
        removeItemDiv.classList.add('dragover')
    })
    removeItemDiv.addEventListener('dragleave', (ev) => {
        ev.preventDefault()
        removeItemDiv.classList.remove('dragover')
    })
    removeItemDiv.addEventListener('drop', (ev) => {
        // Remove the target element and delete
        itemGridDiv.removeChild(dragTarget)
        removeItemDiv.classList.remove('dragover')
        calcCurrGridItems()
        createItemGrid(currGridItems)
    })

    // Preset code
    const presetSelectEl = document.getElementById('customPreset')
    const presetLineUp = {
        'basic': pattyItemGrid,
        'essential': essentialsGrid,
        'locksInOrder': locksInOrderGrid,
        'allKey': AllTheKeyItems
    }
    presetSelectEl.addEventListener('change', (event) => {
        if (presetLineUp[presetSelectEl.value]) {
            createItemGrid(presetLineUp[presetSelectEl.value])
        }
        calcCurrGridItems()
        sendLayoutChange()
    })

    
    const customLockEl = document.getElementById('customLayoutLock')
    customLockEl.addEventListener('click', event => {
        customLockEl.classList.toggle('unlocked')
        disableCustomization(!customLockEl.classList.contains('unlocked'))
    })

    function disableCustomization(enable=true) {
        // go through grid and hide all blank tiles
        for (let el of itemGridDiv.children) {
            if (el.classList.contains('blank'))
                el.classList.toggle('hideImg', enable)
            else
                el.setAttribute('draggable', !enable)
        }
        // // close add toggle and disable
        // FIXME: Dragging is not locked correctly, dont know what this is caused by
        // FIXME: Add btn should disable and hide the itemList.
        // addItemEl.setAttribute('disabled', enable)
        // addItemEl.classList.toggle('open', !enable)
    }

    // Add Item code
    const addItemEl = document.getElementById('customAdd')
    const addItemListCont = document.getElementById('itemListContainer')
    addItemEl.addEventListener('click', (event) => {
        addItemEl.classList.toggle('open')
        addItemListCont.classList.toggle('open', addItemEl.classList.contains('open'))
    })

    const tooltipEl = document.getElementsByClassName('itemTooltip')[0]
    const tooltipToggleEl = document.getElementById('customTooltip')
    // const tooltipTriggerTime = 1000*0.4
    let tooltipBool = false

    tooltipToggleEl.addEventListener('click', (ev) => {
        tooltipToggleEl.classList.toggle('open')
        tooltipBool = tooltipToggleEl.classList.contains('open')
        
        tooltipEl.classList.toggle('show', tooltipBool)
    })

    function enableTooltip(el) {
        el.addEventListener('mouseenter', toolTipMouseEnter)
        el.addEventListener('mousemove', toolTipMouseMove)
        el.addEventListener('mouseleave', toolTipMouseLeave)
    }
    
    enableTooltip(tooltipToggleEl)
    enableTooltip(removeItemDiv)
    enableTooltip(presetSelectEl.parentElement)
    enableTooltip(addItemEl)
    enableTooltip(customLockEl)

    function toolTipMouseEnter (event) {
        let item_id = event.target.getAttribute('item_id')
        if (!item_id) {
            tooltipEl.textContent = `> ${event.target.getAttribute('data-tooltip')}`
        } else {
            let item_obj = keyItemList[item_id]
            tooltipEl.textContent = `> ${item_obj.name} \n${item_obj.desc ? item_obj.desc : ''}`
        }
        
        tooltipEl.classList.toggle('show', tooltipBool)
    }

    function toolTipMouseMove (event) {
        if (!tooltipBool) return

        tooltipEl.style.setProperty('left', event.pageX+'px')
        tooltipEl.style.setProperty('top', event.pageY+'px')
    }

    function toolTipMouseLeave (event) {
        tooltipEl.textContent = `> Hover over elements for help`
        tooltipEl.classList.remove()
    }

    let msgBox = document.querySelector('.msgBox')
    document.querySelector('.msgBox button').addEventListener('click', event => {
        msgBox.classList.remove('show')
    })
    function displayMsgToUser(txt, level=null) {
        msgBox.children[0].textContent = txt
        msgBox.classList.add('show')
        msgBox.classList.remove('error', 'warning')
        if (level == 'error'){
            msgBox.classList.add('error')
        } else if (level == 'warning')
            msgBox.classList.add('warning')
    }




    // STARTUP HERE


    if (window.localStorage.getItem('DS1Rando_1.2patch_notes') == null) {
        displayMsgToUser('Welcome to DS1-auto-tracker 1.2!!\n You can now change the layout of your items or choose presets!')
        window.localStorage.setItem('DS1Rando_1.2patch_notes', 'true')
    }
    
    if (navigator.userAgent.match(/firefox|fxios/i)) {
        displayMsgToUser("This site only works in Chromium browsers.", "error")
    }
    
    let loadedItemGrid = window.localStorage.getItem('DS1Rando_ItemGrid')
    if (loadedItemGrid) {
        createItemGrid(JSON.parse(loadedItemGrid))
        presetSelectEl.value = "custom"
    } else {
        // this is the default
        createItemGrid(pattyItemGrid)
        presetSelectEl.value = "basic"
    }
    calcCurrGridItems()
    createItemList()
    document.querySelector('#itemListContainer input').addEventListener('input',
        searchItemList)
    // STARTUP END

    function createItemList() { // Create item list for adding new items
        for (let item_id in keyItemList) {

            let itemName = keyItemList[item_id]
            let imgEl = createItemImg(item_id)
            itemListDiv.appendChild(imgEl)
            imgEl.addEventListener('dragstart', item_dragstart_handler)
            imgEl.addEventListener('dragend', item_dragend_handler)
        }
    }

    function searchItemList(event) { // filter based on change event
        let filterTxt = event.target.value
        for (let itemEl of itemListDiv.children) {
            if (!itemEl.getAttribute('item_name').toLowerCase().includes(filterTxt)) {
                itemEl.style.display = "none"
            } else {
                itemEl.style.display = "inherit"
            }
        }
    }

    function createItemImg (item_id) {
        let imgEl = document.createElement('img')
        imgEl.src = `img/${item_id}.png`
        imgEl.setAttribute('draggable', true)
        imgEl.setAttribute('item_id', item_id)
        imgEl.setAttribute('item_name', keyItemList[item_id].name)
        imgEl.setAttribute('data-tooltip', keyItemList[item_id].name)
        
        imgEl.addEventListener('mouseenter', toolTipMouseEnter)
        imgEl.addEventListener('mousemove', toolTipMouseMove)
        imgEl.addEventListener('mouseleave', toolTipMouseLeave)
        imgEl.classList.add('itemImage')
        return imgEl
    }

    function createItemGrid(itemFormat) {

        customLockEl.classList.add('unlocked')
        let childrenCopy = Array.from(itemGridDiv.children) // ShallowCopy
        for (let el of childrenCopy) {
            if (!el.classList.contains('debugDisclaimer'))
                itemGridDiv.removeChild(el)
        }
        for (let id in gridImgLink) {
            delete gridImgLink[id]
        }

        if (itemFormat == []) {
            add_item_to_grid(null, 1,1)
            return
        }
        // Create item grid from an array of arrays
        // Using a Row -> Col format, null/empty == nothing
        let maxColLen = 0
        let colLen = 0
        for (let itemRow of itemFormat)
            maxColLen = Math.max(maxColLen, itemRow.length)

        

        for (let row_idx=1; row_idx < itemFormat.length+3; row_idx++) {
            for (let col_idx=1; col_idx < maxColLen+3; col_idx++) {
                
                if (row_idx==1 || row_idx==itemFormat.length+2
                    || col_idx==1 || col_idx == maxColLen+3 ) {
                    add_item_to_grid(null, col_idx, row_idx)
                    continue
                } else {
                    let itemRow = itemFormat[row_idx-2]
                    let item_id = namedItemList[itemRow[col_idx-2]]
                    add_item_to_grid(item_id, col_idx, row_idx)
                }
            }

        }
    }

    function calcCurrGridItems() { // save the current item grid
        while (currGridItems.length > 0)
            currGridItems.pop()
        
        let gridLoc = {}
        // These could be in any order. I need to find min/max then build that
        let max_row = 0
        let max_col = 0
        let item_ref = {}
        for (let el of itemGridDiv.children) {
            if (el.getAttribute('item_id') != null) {
                let el_row = el.style.getPropertyValue('grid-row')
                el_row = parseInt(el_row)
                // el_row = parseInt(el_row.substring(0, el_row.indexOf('/')))-1
                let el_col = el.style.getPropertyValue('grid-column')
                el_col = parseInt(el_col)
                // el_col = parseInt(el_col.substring(0, el_col.indexOf('/')))-1

                max_row = Math.max(el_row, max_row)
                max_col = Math.max(el_col, max_col)
                item_ref[`${el_col},${el_row}`] = el.getAttribute('item_id')
            }
        }

        for (let row=0; row <= max_row; row++) {
            let new_row = [...Array(max_col+1).keys()] // ? way to max Array of length X
            new_row.fill(null, 0, max_col+1)
            currGridItems.push(new_row)
        }

        for (let el_pos in item_ref) {
            let el_loc = el_pos.split(',')
            currGridItems[parseInt(el_loc[1])][parseInt(el_loc[0])] = 
                keyItemList[item_ref[el_pos]].name
        }

        trimGrid()
        window.localStorage.setItem('DS1Rando_ItemGrid', JSON.stringify(currGridItems))
        sendLayoutChange()
        createItemGrid(currGridItems)
    }

    function sendLayoutChange() {
        if (fetchIDPromise) {
            fetchIDPromise.then(() => {
                fetch(`${baseUrl}/speakMic`, 
                    {method: 'POST', mode: 'cors', cache: 'no-cache', 
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({'spkID': spkID, 'layout': currGridItems})}
                )
                keepAliveTs = Date.now()
                console.log("Updated Layout")
            })
        }
    }

    function trimGrid() { // ensure grid is not edge padded

        while (currGridItems[0] && currGridItems[0].every( el => el==null )) {
            currGridItems.shift() // remove top
        }
        if (currGridItems[currGridItems.length-1] && 
                currGridItems[currGridItems.length-1].every(el => el==null )) {
            currGridItems.pop() // remove bottom
        }
        

        while (currGridItems.length != 0 && currGridItems.every(itemRow => itemRow[0] == null, false )) {
            for (let itemRow of currGridItems) {
                itemRow.shift()
            }
        }
        while (currGridItems.length != 0 && currGridItems.every(itemRow => (itemRow[itemRow.length-1] != undefined && itemRow[itemRow.length-1] == null) )) {
            for (let itemRow of currGridItems) {
                itemRow.pop()
            }
        }


    }

    function add_item_to_grid(item_id, col=null, row=null) {
        // Add item to grid
        let imgEl = null
        if (item_id) { // Add img tile to the grid
            imgEl = createItemImg(item_id)
            let item_name = keyItemList[item_id].name
            imgEl.classList.add('transparent')

            itemGridDiv.appendChild(imgEl)
            gridImgLink[item_name] = imgEl
            imgEl.addEventListener('dragstart', item_dragstart_handler)
            imgEl.addEventListener('dragend', item_dragend_handler)
        } else { // Add a blank tile that accepts drop events
            imgEl = document.createElement('img')
            imgEl.src = `img/plus_icon.png`
            imgEl.setAttribute('draggable', false)
            imgEl.classList.add('itemImage', 'blank')
            
            itemGridDiv.appendChild(imgEl)
        }
        
        if (col != null)    imgEl.style.setProperty('grid-column', col)
        if (row != null)    imgEl.style.setProperty('grid-row', row)

        imgEl.addEventListener('dragleave', item_dragleave_handler)
        imgEl.addEventListener('dragover', item_dragover_handler)
        imgEl.addEventListener('drop', item_drop_handler)
    }

    function item_dragstart_handler(ev) {
        // Add the target element's id to the data transfer object
        ev.dataTransfer.setData("item_id", ev.target.getAttribute('item_id'));
        ev.dataTransfer.setData("item_name", ev.target.getAttribute('item_name'));
        ev.dataTransfer.dropEffect = "move";
        ev.dataTransfer.setDragImage(ev.target, 10, 10)
        
        dragTarget = ev.target
        dragTarget.classList.add('dragging')
    }

    function item_dragend_handler(ev) {
        dragTarget.classList.remove('dragging')
        dragTarget = null
    }

    function item_dragover_handler(ev) { // This is necessary

        if (!dragTarget ||
            dragTarget.getAttribute('item_id') == ev.target.getAttribute('item_id')) {
            ev.dataTransfer.dropEffect = "none";
            return
        }
        ev.preventDefault();
        ev.dataTransfer.dropEffect = "move";
        ev.target.classList.add('dragover')
    }

    function item_dragleave_handler(ev) { // Reset the 
        ev.preventDefault();
        ev.dataTransfer.dropEffect = "move";
        ev.target.classList.remove('dragover')
    }

    function item_drop_handler(ev) {
        // Move the new item to this location
        ev.preventDefault();
        const item_id = ev.dataTransfer.getData("item_id");

        const targetEl = ev.target
        let tarLoc = [targetEl.style.getPropertyValue('grid-column'),
                        targetEl.style.getPropertyValue('grid-row')]
        console.log(`Moving ${item_id} to (${tarLoc})`)
        // Delete old element
        const currEl = dragTarget
        let dragLoc = [currEl.style.getPropertyValue('grid-column'),
                        currEl.style.getPropertyValue('grid-row')]

        if (currEl.parentElement == targetEl.parentElement) {
            // both in itemGrid, swap locations
            targetEl.style.setProperty('grid-column', dragLoc[0])
            targetEl.style.setProperty('grid-row', dragLoc[1])

            // Move currEl over here
            currEl.style.setProperty('grid-column', tarLoc[0])
            currEl.style.setProperty('grid-row', tarLoc[1])
        } else {
            // If drag element isn't in grid, create new image at target location
            add_item_to_grid(item_id, tarLoc[0], tarLoc[1])
            // then delete old item
            const targetElParent = targetEl.parentElement
            targetElParent.removeChild(targetEl)
            delete targetEl
        }
        calcCurrGridItems()

        ev.target.classList.remove('dragover')
        presetSelectEl.value = "custom"
    }


    // ------------------------------------------------------------------------
    // SAVE-FILE HANDLERS
    // ------------------------------------------------------------------------

    const profileSize = 0x060030;   // This seems to work the most consistently
    // const profileSize = 0x1f138; // Don't know why this change was made!!! Breaks only DS:R files
    // const profileSize = 0x60190; // From DS1FP website
    // document.title = `${profileSize}`
    const AES_KEY_BYTES = Uint8Array.from([0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10]).buffer;
    const AES_IV_BLOCKLEN = 16; // 16 bytes
    let AES_Crypto_Key = null;
    let AES_Crypto_Promise = null; // Doing the crypto promise/etc once DSR save file is determined

    const dropZone = document.querySelector('.dropZone')
    dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = "link";
    })
    dropZone.addEventListener('drop', async event => {
        event.preventDefault();
        
        if (event.dataTransfer.items) {
            for (let file of event.dataTransfer.items) {
                if (file.kind === 'file') {
                    fileHandle = await file.getAsFileSystemHandle();
                    loadSaveFile(fileHandle)
                    break
                }
            }
        }
    })


    //TODO: Too many async / awaits in this chain
    document.querySelector('.dropZone').addEventListener('dblclick', async() => {
        
        let pickerOpt = {
            types: [{description:'Dark Souls Save File',
                    accept: { 'savefile/sl2': ['.sl2']}
                }]
        }
        infoBox.textContent = "Checking";
        // console.log(pickerOpt)
        // let v = 234
        [fileHandle] = await window.showOpenFilePicker(pickerOpt)
        // Cancelled request is obvious to user
        loadSaveFile(fileHandle)
    })

    if (!window.showOpenFilePicker)
        infoBox.textContent = "File System API not supported :( \n Please use latest version of Chrome";

    async function loadSaveFile (fileHandle) {
        // Load file & fileHandle
        actualFile = await fileHandle.getFile()
        document.querySelector('#steps').classList.add('min')

        if (await actualFile.slice(0, 4).text() == 'BND4') {
            if (!spkID)
                setUpSpeaker()
            readBND4File(actualFile) 
            updateFileProperties(actualFile)

            // Start polling of the file 
            clearInterval(filePollTimeout)
            filePollTimeout = setInterval( async () => {
                // poll file change every few seconds
                if (! (await checkFileValid(actualFile)) ) {
                    actualFile = await fileHandle.getFile()
                    readBND4File(actualFile)
                }
                updateFileProperties(actualFile)
            }, filePollTime)
        } else {
            console.error('This is not a valid BND4 file')
            infoBox.textContent = "This doesn't appear to be a DS1 Save File"
            displayMsgToUser('This is not a valid BND4 file', 'warning')
        }
    }

    async function checkFileValid (file) {
        try {
            let filetext = await file.slice(0, 1).text() // 1 byte
        } catch (exception) {
            return false // File is not readable due to on-disk modification, reload fileHandle
        }
        return true
    }

    function updateFileProperties (file) {
        // takes File NOT FileHandle
        fileName.textContent = actualFile.name + ' '+ (DSPTE_ReadMode ? '[DS1]' : '[DSR]')
        fileLastUpdated.textContent =  `${parseToTimeElapsed(Date.now() - actualFile.lastModified)}ago`
    }

    function parseToTimeElapsed (ms) {
        let timestr = ""
        const sec = 1000
        const min = sec * 60
        const hr = min * 60
        const day = hr * 24
        if (ms > day) {
            timestr += `${Math.floor(ms/day)}d `
            ms = ms % day
        }
        if (ms > hr) {
            timestr += `${Math.floor(ms/hr)}h `
            ms = ms % hr
        }
        if (ms > min) {
            timestr += `${Math.floor(ms/min)}m `
            ms = ms % min
        }
        if (ms > sec) {
            timestr += `${Math.floor(ms/sec)}s `
            ms = ms % sec
        }
        return timestr
    }

    //NOTE: convert to Readable Stream, maybe faster?
    async function readBND4File (file) {
        // Adapted from gabtoubl's js port

        let b_idx = 0;
        skipBytes = (bytes) => b_idx += bytes
        read = (start, bytes) => file.slice(start, bytes)

        let format = await file.slice(0, 4).text() // format at position 0, UTF-8
        if (format != 'BND4') {
            console.warn('Not a valid DS1 save file, missing BND4 tag')
            displayMsgToUser('This is not a valid BND4 file', 'warning')
            return
        }

        b_idx = 0x18; // version offset
        let version = await file.slice(b_idx, b_idx+8).text()
        console.log(`version: ${version}`)

        if (version == '00000001') {
            console.info('Appears to be a DS1:PTDE save file')
            DSPTE_ReadMode = true;
        } else if (version == '\0\0\0\0\0\0\0\0') { //DSR has null data where the version no. is
            console.info('Appears to be a DS1:R save file')
            if (window.crypto && window.crypto.subtle) { // Generating a key via a promise
                AES_Crypto_Promise = window.crypto.subtle.importKey('raw', AES_KEY_BYTES, {'name':'AES-CBC'}, false, ['decrypt'])
                console.info('Starting up AES decryption')
            } else { 
                console.warn('This browser does not support the crypto module; please update!') //It was released in 2014, what you doing
                return
            }
            DSPTE_ReadMode = false;
        }

        b_idx = 0x50; // container header data starts at 0x40, going straight to the start offset at 0x50
        profileStartOffset = [] // save-file offset is defined at beginning
        // Capture player/profile offsets
        for (let i=0; i<11; i++) {
            profileStartOffset.push( new Uint32Array(await file.slice(b_idx, b_idx+4).arrayBuffer())[0] ); // convert to int (use int8array)
            b_idx += 32; // containers are 32 bytes high/long
        }
        // 11th header is for grabbing some additional stuff
        // console.log(profileStartOffset)

        oldPlayers = players
        players = []

        // Start reading player/profiles
        // NOTE: Change performance data to use measure & etc
        // TODO: Need to rewrite the async logic SO player parse is parallel & has early out
        let pt = performance.now()
        for (let i=0; i<10; i++) {
            let savedPlayer = null;
            if (version == '00000001') {
                let p1 = performance.now()
                savedPlayer = await readPlayerData(file.slice(profileStartOffset[i], profileStartOffset[i]+profileSize))
                console.log(`DS1 player took ${performance.now() - p1}ms`)
            } else {
                let p2 = performance.now()
                let saveSlotBlob = file.slice(profileStartOffset[i], profileStartOffset[i]+profileSize)
                let saveSlotPromise = saveSlotBlob.slice(AES_IV_BLOCKLEN).arrayBuffer()
                let profile_IV = await saveSlotBlob.slice(0, AES_IV_BLOCKLEN).arrayBuffer()

                AES_Crypto_Key = (!AES_Crypto_Key) ? await AES_Crypto_Promise : AES_Crypto_Key

                let saveSlotData = new Uint8Array(await saveSlotPromise)
                let decryptSaveSlotBuffer = null;
                try {
                    decryptSaveSlotBuffer = await window.crypto.subtle.decrypt( {name: 'AES-CBC', iv: profile_IV}, AES_Crypto_Key, saveSlotData)
                } catch {
                    console.error("Failed to decrypt!!!")
                    displayMsgToUser('Decrypt had an unknown error! Please send savefile if possible to dev', 'error')
                    return;
                }

                let decryptSaveSlotBlob = new Blob([decryptSaveSlotBuffer])
                console.log(`DSR player decrypt ${performance.now() - p2}ms`)

                savedPlayer = await readPlayerData(decryptSaveSlotBlob.slice(8)) // For some reason, this is offset by 8 bytes.
                console.log(`DSR player took ${performance.now() - p2}ms`)
            }
            // if (!savedPlayer) break //cant early exit if empty slots are first
        }
        console.log(`All players took ${performance.now() - pt}ms`, players)

        // Now lets compare the hashes and see if there was a change
        calculatePlayerDiff()

        // send update and let client figure out
        fetchIDPromise.then(() => {
        // if (spkID) {
            fetch(`${baseUrl}/speakMic`, 
                {method: 'POST', mode: 'cors', cache: 'no-cache', 
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({'spkID': spkID, 'player': trackedPlayer}, 
                    (key, val) => {
                        if (val instanceof ArrayBuffer) {
                            return undefined
                        }
                        return val
                    })
                }
            )
            keepAliveTs = Date.now()
            console.log("Updated Save-Data")
        })
        // NOTE: I could compress & only send diffs, but its ~ 500B which is nothing
    }

    async function readPlayerData(file) {
        let p = performance.now()

        let playerHeaderBuffer = await file.slice(0, 0x170).arrayBuffer() // read player data from the blob
        let player = {}

        // player.buffer = new Uint8Array(await file.arrayBuffer())
        player.buffer = await file.arrayBuffer()
        // player.headerBuffer = await file.arrayBuffer(0, (0x100-0x6c))
        player.level = new Uint32Array(playerHeaderBuffer, 0xE8, 1)[0];
        if (player.level == 0) {
            console.warn('Level 0 player detected')
            return false 
        }
        
        player.souls = new Uint32Array(playerHeaderBuffer, 0xec, 1)[0];
        player.faith = Number(new BigUint64Array(playerHeaderBuffer, 0xc8, 1)[0]) // max stat is 99
        
        // gotta check for null-chars cause of C-strings
        // The dataset says 4 byte c_char_p, but it just works better casting from 16-bit chars
        // player.name8 = new TextDecoder().decode(new Uint8Array(playerHeaderBuffer, 0x100, 28)) // name via UTF-16
        player.name8 = String.fromCharCode(...new Uint16Array(playerHeaderBuffer, 0x100, 14)) // name via UTF-16
        let nullCharIdx = player.name8.indexOf(String.fromCharCode(0))
        player.name = (nullCharIdx > 0) ? player.name8.substring(0, nullCharIdx) : player.name8 // assuming name is not null here
        players.push(player)

        // simple hash for player comparison NOTE: None of this is unique, I don't know what values to use to verify.
        // player.headerHash = player.name + String.fromCharCode(player.souls >> 16, player.souls & 0xFFFF, player.level, )

        console.log(`player ${player.name} computed header in ${performance.now()-p}ms`)

        // Read item list
        const backpackOffset = DSPTE_ReadMode ? 0x2E0 : 0x2F8   // Note DSR seems to be offset by 24 bytes
        const backpackEndOffset = DSPTE_ReadMode ? 0xE2E0 : 0xE2F8
        player.items = {}
        player.keyItems = []
        // player.itemHash = ''
        p = performance.now()
        let backpackArrayBuffer = (await file.slice(backpackOffset, backpackOffset + backpackEndOffset).arrayBuffer())

        for (let item_idx = 0; item_idx + backpackOffset < backpackEndOffset; item_idx += 4*7) {
            let item = {}
            let id = new Uint32Array(backpackArrayBuffer, item_idx+4, 1)[0]
            // NOTE: After ~100 0xFFFFFFFF item ids I should quit the item check, however item check completes in <10ms on my machine
            // so skipping ~400 items might not save much time

            if (true && id < 0xFFFFFFFF) { // empty slots have MAX_32_INT value
                if (keyItemList[id]) {
                    item.name = keyItemList[id].name // only key item list lookup
                    if (id == 190000 || id == 1396000)
                        player.keyItems.push("Light Source")
                    else 
                        player.keyItems.push(keyItemList[id].name) // set value for diffs later
                }
                // there can be the same item in 2 slots but IDK
                item.amount = new Uint32Array(backpackArrayBuffer, item_idx+8, 1)[0]
                // NOTE: I don't care about item type but note item ids are not unique 
                item.have = (0 != new Uint32Array(backpackArrayBuffer, item_idx + 16, 1)[0]) // convert to boolean
                player.items[id] = item
                // player.itemHash += String.fromCharCode(id, item.amount, item.have)
            }
        }

        console.log(`player ${player.name} computed items in ${performance.now()-p}ms`)
        return true
    }

    function calculatePlayerDiff() {

        if (!players.length) {
            infoBox.textContent = 'No players found'
            return
        }

        // Diff player data with latest parsed data
        let playerStats = []
        for (let player of players) {
            // playerStats.push(`${player.name}: \tLv. ${player.level} \t| ${player.souls} souls \t| ${Object.keys(player.items).length} items `)
            playerStats.push(`<tr><td>${player.name}</td> <td>${player.level}</td><td>${player.souls} souls</td> <td>${Object.keys(player.items).length} items </td>`)
        }

        /*
            null        -> nothing
            players     -> display player stats + trackLastPlayer
            old + players -> show stats + trackUpdated player
        */

        let nTrackedPlayer = null
        let nChanged = 0
        if (oldPlayers) {
            for (let i=0; i<players.length; i++) {
                let changeFound = false
                if (oldPlayers[i] && oldPlayers[i].name == players[i].name) {
                    playerStats[i] += '<td>F</td>'
                    
                    if (!bufferComparison(oldPlayers[i].buffer, players[i].buffer)) {
                        playerStats[i] += '<td>B</td>'
                        changeFound = true
                    }
                    // if (oldPlayers[i].headerHash != players[i].headerHash) {
                    //     playerStats[i] += '<td>H</td>'
                    //     nTrackedPlayer = players[i]
                    //     changeFound = true
                    // }
                    // if (oldPlayers[i].itemHash != players[i].itemHash) {
                    //     playerStats[i] += '<td>I</td>'
                    //     nTrackedPlayer = players[i]
                    //     changeFound = true
                    // }
                }
                playerStats[i] += '</tr>'

                if (changeFound) {
                    nTrackedPlayer = players[i]
                    nChanged++
                }
            }
        }

        if (nChanged > 1) console.warn('More that 1 player updated in one update.')
        
        infoBox.innerHTML = `<table> <thead><th>Name</th> <th>Level</th> <th>Souls</th> <th>Items</th> <th>Track</th></thead>
            ${playerStats.join('\n')} </table><br/>`

        // nTrackedPlayer = nTrackedPlayer || players[players.length-1] 

        //nTrackedPlayer either last changed or last new
        if (trackedPlayer) { // if was tracking
            if (nTrackedPlayer) {
                if (trackedPlayer.name == nTrackedPlayer.name) // if same player, allow intersect to update items
                    infoState.textContent = `Tracking ${nTrackedPlayer.name}`
                else { // reset tracked player, causes intersect to do a catch-up
                    trackedPlayer = null 
                    infoState.textContent = `Swap Track to ${nTrackedPlayer.name}`
                }
            } else // if !nTrackedPlayer, no update
                infoState.textContent = `Tracking ${trackedPlayer.name} [nop]`
        } else {
            if (nTrackedPlayer) {
                infoState.textContent = `Tracking ${nTrackedPlayer.name} [new]`
            } else {
                infoState.textContent = `Waiting for first update`
            }
        }

        // if (trackedPlayer && trackedPlayer.name == nTrackedPlayer.name) { // verify its the same player
        //     // infoBox.innerHTML += `Tracking ${nTrackedPlayer.name} ...\n`
        //     infoState.textContent = `Tracking ${nTrackedPlayer.name}`
        // } else if (!trackedPlayer && nTrackedPlayer) { // first read and only 1 change was found
        //     infoState.textContent = `Now Tracking ${nTrackedPlayer.name} (first update)`
        // } else if (trackedPlayer && trackedPlayer.name != nTrackedPlayer.name) {
        //     trackedPlayer = null // reset tracked player, causes intersect to do a catch-up
        //     infoState.textContent = `Swap track to ${nTrackedPlayer.name}`
        // } else {
        //     infoState.textContent = `Waiting for first update`
        // }

        // do set intersect (requires nTrackedPlayer)
        if (!nTrackedPlayer) return

        let initKeyItems = (trackedPlayer && trackedPlayer.keyItems) || []
        let keyItemIntersect = nTrackedPlayer.keyItems.filter(ki => !initKeyItems.includes(ki))

        for (let imgLink in gridImgLink) {
            if (nTrackedPlayer.keyItems.includes(imgLink)) // NOTE: ew search over array
                gridImgLink[imgLink].classList.remove('transparent')
            else
                gridImgLink[imgLink].classList.add('transparent')
        }

        trackedPlayer = nTrackedPlayer
    }


    function bufferComparison(bufferA, bufferB) {
        if (bufferA.length !== bufferB.length) {
            return false
        }

        let dvA = new DataView(bufferA)
        let dvB = new DataView(bufferB)
        
        for (let i = 0; i<dvA.byteLength/4; i++) {
            if (dvA.getUint32(i) !== dvB.getUint32(i)) return false
        }
        return true
    }


</script>
</html>