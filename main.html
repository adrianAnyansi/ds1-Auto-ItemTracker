<html>
    <head>
        <script src="keyItemList.js"></script>
        <title>DS1-Auto-Item-Tracker-MAIN</title>
        <meta charset="utf-8"/>
    </head>
<style>
    .editProp {
        color: orangered;
        min-width: 5rem;
        display: inline-block;
        font-family: monospace;
    }
    
    .fileInfo {
        font-size: 1rem;
        position: absolute;
        color: #141450;
        top: 0rem;
        right: 1rem;
        width: 30%;
    }

    .dropZone {
        background: lightgray;
        /* width: 50rem; */
        /* height: 6rem; */
        margin-bottom: 2rem;
        font-size: 8rem;
        font-weight: 600;
        text-align: center;
        user-select: none;
        border: dotted gray 0.2rem;
        position: relative;
        color: #565252
    }

    .dropBg, .dropBBg {
        color: #131515;
        font-size: 0.8rem;
        position: absolute;
        top: 0.5rem;
        right: 50%;
        transform: translateX(50%);
    }

    span.dropBBg {
        /* color: #7d7777; */
        bottom: 0.5rem;
        top: inherit;
    }

    .ib {
        display: inline-block;
    }

    body {
        background-color: snow;
    }

    body div {
        margin: 0.25rem;
    }

    #infoBox {
        white-space: pre;
    }

    #infoBox table {
        border-collapse: collapse;
    }
    
    #infoBox table tbody tr:nth-child(odd) {
        background-color: #e2e2e2;
    }

    #infoBox table td {
        border: 2px solid #333A;
        padding: .2rem .5rem;
    }

    #infoState {
        font-size: 1.1rem;
        font-weight: bold;
    }


    .inlineGroup {
        display: inline-block;
        background-color: orange;
        padding: .2em;
        font-family: "Candara";
    }

    #customBar {
        position: relative;
        display: flex;
    }

    #customRemove {
        display: inline-block;
        background-color: lightcoral;
        padding: 0.2em 1em;
        margin: 0;
    }

    #customRemove.dragover {
        background-color: red;
    }

    #customAdd {
        background-color: lightblue;
        color: black;
        cursor: pointer;
        border: none;
        padding: 0.5em 1em;
        font-weight: bold
    }
    #customAdd.open {
        background-color: blue;
        color: white;
    }

    #itemListContainer {
        background: slategray;
        padding: 0.4em 0.2em;
        position: absolute;
        left: 100%;
        width: 30em;
        z-index: 1;
        display:none
    }
    #itemListContainer.open {
        display: block;
    }
    #itemListContainer input {
        background-color: gray;
        border-style: dashed;
        border-color: #575b5e;
    }

    #itemList {
        grid: repeat(2, fit-content(55px)) / auto-flow;
        display: grid;
        gap: 5px;
        overflow-x: scroll;
        background-color: #41464c;
        padding: 0.5em 0;;
    }

    #itemList .itemImage {
        width: 55px;
        height: 55px;

    }

    .itemGrid {
        display: grid;
        /* grid-template-columns: repeat(3, 100px); */
        gap: 10px;
        /* grid-auto-rows: minmax(50px, auto); */
    }

    .itemImage {
        filter: drop-shadow(5px 5px 4px #111);
        width: 90px;
        height: 90px;
        position: relative;
        object-fit: contain;
        margin: 0;
    }

    .itemImage.blank {
        filter: none;
    }

    .itemImage.dragover {
        background-color: lightblue;
    }

    .itemImage.dragging {
        opacity: 0.2;
    }

    .itemImage img {
        object-fit: contain;
    }

    .itemImage[data-tooltip]::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 10%;
        top: 20%;
        z-index: 1;
        font-size: 14px;
        color: white;
    }

    .itemImage.transparent {
        opacity: 0.5;
    }

    .browserSourceBtn {
        /* padding: 0.2rem 0.6rem; */
        padding: 0;
        color: black;
        background: #d8d8d838;
        border: 2px solid #46415f;
        font-weight: bold;
        text-align: center;
        cursor: pointer;
        /* user-select: none; */
        position: relative;
        width: 100%;
        font-size: 0.9rem;
        height: 2rem;
        transition: border 0.2s, background 0.2s;
        /* border-radius: 0 0 15% 15%; */
    }

    .browserSourceBtn:hover {
        background: #94bfff38;
        border: 2px solid #3334e2;
    }

    /* .hangLeft {
        background-color: #000C;
        font-family: monospace;
        color: snow;
        text-shadow: 2px 1px black;
        border-right: 2px solid black;
        margin: 0;
        padding: 0.1rem 0.3rem;
        font-size: 1.2rem;
        cursor: pointer;
    } 
    */

    .browserSourceBtn:disabled + .hangLeft {
        cursor: not-allowed;
    }

    .browserSourceBtn:disabled {
        color: #504c4c;
        --dark-bg: #EEE3;
        --light-bg: #3033;
        background: repeating-linear-gradient(135deg, var(--light-bg), var(--light-bg) 10px, var(--dark-bg) 10px, var(--dark-bg) 20px, var(--light-bg) 20px);
        user-select: none;
        cursor: not-allowed;
    }

    .browserSourceBtn::after {
        content: 'Copied!';
        background-color: black;
        color: white;
        position: absolute;
        top: 0;
        transform: translate(-50%, -130%);
        left: 50%;
        padding: 0.2rem;
        opacity: 0;
        transition: opacity 2s; 
    }


    .browserSourceBtn::before { /* This is the tiny triangle btw*/
        content: '';
        /* background-color: red; */
        position: absolute;
        top: 0;
        left: 50%;
        transform: translate(-50%, -100%);
        width: 0;
        height: 0;
        border-left: .5rem solid transparent;
        border-right: .5rem solid transparent;
        border-top: .45rem solid black;
        opacity: 0;
        transition: opacity 2s;
    }

    .browserSourceBtn:active::after,
    .browserSourceBtn:active::before {
        opacity: 1;
        transition: opacity 0s; 
        content: 'Copied!';
    }

    .autoCircle {
        background: red;
        border-radius: 50% 50%;
    }

    .debugDisclaimer {
        transform: translateX(-140px) rotate(-20deg);
        position: absolute;
        font-size: 180px;
        writing-mode: vertical-rl;
        opacity: 30%;
        color: red;
        user-select: none;
    }

    .title {
        font-size: 1.7rem;
        font-weight: bold;
        margin: 0;
        font-family: system-ui;
        color: #3e4042;
    }

    .title span {
        font-size: 0.7rem;
        font-weight: bold;
    }

    .step {
        /* padding-top: 1rem; */
        font-size: 1.1rem;
        border-top: 1px solid #3336;
        padding: 1rem 0;
        overflow: hidden;
        max-height: 5rem;
        margin: 0
    }

    .step .step_num {
        font-size: 1.5rem;
        color: black;
        font-weight: bold;
        
        border: 3px solid black;
        padding: 3px;
        border-radius: 50%;
        display: inline-block;
        width: 1.5rem;
        height: 1.5rem;
        line-height: 1.5rem;
        text-align: center;
    }

    .save_loc {
        background-color: #eaeaea;
        font-family: system-ui;
        /* color: #25124a; */
        font-weight: 600;
        padding: 0.2rem;
    }

    .bold {
        font-weight: bold;
    }

    #steps.min .step:first-child,
    #steps.min .step:nth-child(2) {
        max-height: 0px;
        margin: 0px;
        padding: 0px;
        transition: max-height 1s, margin 1s, padding 1s;
    }

</style>

<body>
    
    <div style="display: flex">
        <div class="debugContainer">
        <div id="customBar">
            <button id="customLayout">Layout</button>
            <span class="inlineGroup">
                <span>Choose Preset:</span>
                <select id="customPreset">
                    <option value="basic" selected>Basic Only</option>
                    <option value="patty">Patty</option>
                    <option value="allKey">All Key Items</option>
                    <option value="" disabled>Custom</option>
                </select>
            </span>
            <span id="customRemove">üóëÔ∏èDrag here to RemoveüóëÔ∏è</span>
            <span id="customAdd">Add</span>
            <div id="itemListContainer">
                <div>
                    <span>üîç</span>
                    <input type="search">
                </div>  
                <div id="itemList">
                </div>

            </div>
        </div>
        <div class="itemGrid">
            <p class="debugDisclaimer">DEBUG</p>
        </div>
        </div>
        
        <div>
            <div class="dropZone">+
                <span class="dropBg">Drop save file .sl2 here</span>
                <span class="dropBBg">Or double click and select a file</span>
                <div class="fileInfo">
                    <p>File name: <span id="fileName" class="editProp"></span></p> 
                    <p>Updated: <span id="lastUpdated" class="editProp"></span></p>
                </div>
            </div>

            <p class="title"> DS1:PTE / DS1R Auto-Tracker<span class="version">1.1</span></p>
            <div id="steps">
            <p class="step">
                <span class="step_num">1</span> Find your DS1 <span class="bold">save file</span> at <br/>
                <span class="save_loc">Documents \ NBGI \ Dark Souls &ltRemastered&gt \ &ltDRAKS0005&gt.sl2</span><br/>

            </p>
            <p class="step">
                <span class="step_num">2</span>
                <span class="bold">Drag & Drop</span> your save file to the gray zone <br/>
                <span class="bold">OR Double-click</span> the gray zone and select your save file.
            </p>
            <p class="step" style="position:relative">
                <span class="step_num">3</span>
                <span class="bold">Click</span> and Copy this link to use as a <span class="bold">browser source</span> <br/>
                <div style="display:flex" id="browserHolder">
                    <button class="browserSourceBtn" disabled>Waiting...</button>
                    <!-- <button class="hangLeft" disabled>Copy</button> -->
                </div>
            </p>
            <p class="step">
                <span class="step_num">4</span>
                Keep this page <span class="bold">open</span> and ENJOY!
            </p>
            <p>Debug info: <span id="infoState"></span></p>
            <p id="infoBox"></p>
            
            </div>
        </div>
    </div>
</body>

<script>
    let fileHandle;
    let actualFile;
    let filePollTimeout = null;
    const filePollTime = 2000;
    let DSPTE_ReadMode = false;

    let players = null;
    let oldPlayers = null;

    // Request ID & save in local storage
    const baseUrl = (window.location.protocol != 'file:') ? 
        'https://ds1.leagueautotimer.dev' : 'http://localhost:8081'
    const currHostname = window.location.origin
    const displayUrl = '/display.html'
    const keepAliveTimeout = 1000 * 10 * 1; // default to 15s keep alive
    let fetchIDPromise = null
    let spkID = null
    let earID = null
    let keepAliveTs = Date.now()
    // TODO: Change timing of reserve & keep-alive to after file init 
    let keepAliveInterval = null
    
    // Send key
    async function setUpSpeaker () {
        console.log(`Sending key ${window.localStorage.getItem('DS1RandoMic_ID')}`)

        fetchIDPromise = fetch(`${baseUrl}/pickMic`, {method: 'POST', mode: 'cors', cache: 'no-cache', 
            headers: {'Content-Type': 'text/plain'},
            body: window.localStorage.getItem('DS1RandoMic_ID')}
        ).then(async resp => {
            
            let IDPromise = null
            if (resp.status == 201) {
                IDPromise = resp.text().then(text => {
                    let sp_text = text.split(':')
                    window.localStorage.setItem('DS1RandoMic_ID', sp_text[0])
                    window.localStorage.setItem('DS1RandoMic_Spk', sp_text[1])
                    console.log(`Updated keys to ${text}`)
                })
            } else if (resp.status == 204) {
                console.log('Allowed to use key')
                IDPromise = Promise.resolve(true)
            } else {
                infoBox.textContent = `Got an error response from server: ${resp}`
                return
            }

            // console.log(IDPromise)

            await IDPromise;
            // resolve the button/auto stuff, and set values
            spkID = parseInt(window.localStorage.getItem('DS1RandoMic_ID'))
            earID = parseInt(window.localStorage.getItem('DS1RandoMic_Spk'))
            console.log('Verified server conn')
            copyDisplayLink.removeAttribute('disabled')
            copyDisplayLink.textContent = `${currHostname}${displayUrl}?ear=${earID}`

            keepAliveInterval =  setInterval( () => {
                if (spkID && keepAliveTs < Date.now() - keepAliveTimeout ) {
                    resp = fetch(`${baseUrl}/speakMic`, 
                        {method: 'POST', mode: 'cors', cache: 'no-cache', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({'spkID': spkID, 'keep-alive': true})}
                    ).then(resp => {
                        if (resp.status == 401) {
                            console.log('Server rejected spkID. Refreshing')
                            setUpSpeaker() // TODO: Review setup the speaker and file read
                            readBND4File(actualFile)
                        }
                    })
                    keepAliveTs = Date.now()
                    // console.log("Exec keep-alive")
                }
            }, keepAliveTimeout)

        }, err => { // else something went wrong
            infoBox.textContent = "Unable to connect to server."
            console.log(err)
            throw new Error('This cannot continue (cause server not available)')
        })
    }

    let trackedPlayer = {} // this is a diff with player obj

    // on-screen elements
    const copyDisplayLink = document.querySelector('.browserSourceBtn');
    copyDisplayLink.addEventListener('click', event => {
        // copy url to clipboard
        navigator.clipboard.writeText(`${currHostname}${displayUrl}?ear=${earID}`)
    })

    const fileName = document.querySelector('#fileName')
    const fileLastUpdated = document.querySelector('#lastUpdated')
    const infoBox = document.querySelector('#infoBox')
    const infoState = document.querySelector('#infoState')
    const itemGridDiv = document.querySelector('.itemGrid')
    const itemListDiv = document.querySelector('#itemList')

    // Item Grid presets
    const basicsOnlyItemGrid = [["Lordvessel",         "Orange Charred Ring", "Seath Bequeathed Lord Soul Shard"],
                      ["Covenant of Artorias", "Key to Depths",       "Four Kings Bequeathed Lord Soul Shard"], 
                      ["Peculiar Doll",       "Annex Key",           "Nito Lord Soul"],
                      ["Broken Pendant",     "Light Source",         "Bed of Chaos Lord Soul"],
                      ["Key to the Seal",  ,  "Basement Key"],
                      ["Blighttown Key",   "Crest of Artorias"]]

    const pattyItemGrid = [
        ["Lordvessel", "Orange Charred Ring", "Seath Bequeathed Lord Soul Shard"],
        ["Covenant of Artorias", "Key to Depths",       "Four Kings Bequeathed Lord Soul Shard"],
        ["Peculiar Doll",       "Annex Key",           "Nito Lord Soul"],
        ["Broken Pendant",     "Light Source",         "Bed of Chaos Lord Soul"],
        ["Key to the Seal",  "Darkmoon Seance Ring",  "Basement Key"],
    ]

    const AllTheKeyItems = [
        ["Key to Depths", "Annex Key", "Dungeon Cell Key", "Cage Key", "Key to New Londo Ruins" ],
        ["Basement Key",  "Big Pilgrim's Key", "Key to the Seal",  "Crest Key", "Mystery Key"],
        ["Residence Key", "Sewer Chamber Key", "Undead Asylum F2 East Key", "Watchtower Basement Key", "Key to the Seal"],
        ["Covenant of Artorias", "Crest of Artorias",  "Darkmoon Seance Ring", "Orange Charred Ring", "Peculiar Doll", "Broken Pendant"],
        ["Lordvessel", "Seath Bequeathed Lord Soul Shard", "Four Kings Bequeathed Lord Soul Shard", "Nito Lord Soul", "Bed of Chaos Lord Soul"],
    ]
    // ITEM GRID CONTAINER
    const itemPresets = [basicsOnlyItemGrid, pattyItemGrid, AllTheKeyItems]

    const gridImgLink = {} // Used to set/unset the items based on save-file
    let dragTarget = null   // save drag-start target for swaps/spawns
    const currGridItems = []

    // Remove icon
    const removeItemDiv = document.getElementById('customRemove')
    removeItemDiv.addEventListener('dragover', (ev) => {
        ev.preventDefault()
        ev.dataTransfer.dropEffect = 'move'
        removeItemDiv.classList.add('dragover')
    })
    removeItemDiv.addEventListener('dragleave', (ev) => {
        ev.preventDefault()
        removeItemDiv.classList.remove('dragover')
    })
    removeItemDiv.addEventListener('drop', (ev) => {
        // Remove the target element and delete
        itemGridDiv.removeChild(dragTarget)
        removeItemDiv.classList.remove('dragover')
    })

    // Preset code
    const presetSelectEl = document.getElementById('customPreset')
    presetSelectEl.addEventListener('change', (event) => {
        if (presetSelectEl.value == "basic") {
            createItemGrid(basicsOnlyItemGrid)
        } else if (presetSelectEl.value == 'patty') {
            createItemGrid(pattyItemGrid)
        } else if (presetSelectEl.value == 'allKey') {
            createItemGrid(AllTheKeyItems)
        }
    })

    // Add Item code
    const addItemEl = document.getElementById('customAdd')
    const addItemListCont = document.getElementById('itemListContainer')
    addItemEl.addEventListener('click', (event) => {
        addItemEl.classList.toggle('open')
        addItemListCont.classList.toggle('open', addItemEl.classList.contains('open'))
    })


    // STARTUP HERE
    // TODO: Load the item format from the Memory/etc
    createItemGrid(AllTheKeyItems)
    createItemList()
    // STARTUP END

    function createItemList() { // Create item list for adding new items
        for (let item_id in keyItemList) {

            let itemName = keyItemList[item_id]
            let imgEl = createItemImg(item_id)
            itemListDiv.appendChild(imgEl)
            imgEl.addEventListener('dragstart', item_dragstart_handler)
            imgEl.addEventListener('dragend', item_dragend_handler)
        }
    }

    function createItemImg (item_id) {
        let imgEl = document.createElement('img')
        imgEl.src = `img/${item_id}.png`
        imgEl.setAttribute('draggable', true)
        imgEl.setAttribute('item_id', item_id)
        imgEl.setAttribute('item_name', keyItemList[item_id].name)
        imgEl.classList.add('itemImage')
        return imgEl
    }

    function createItemGrid(itemFormat) {
        let childrenCopy = Array.from(itemGridDiv.children) // ShallowCopy
        for (let el of childrenCopy) {
            if (!el.classList.contains('debugDisclaimer'))
                itemGridDiv.removeChild(el)
        } 
        // Create item grid from an array of arrays
        // Using a Row -> Col format, null/empty == nothing
        let maxRowLen = 0
        for (let itemRow of itemFormat)
            maxRowLen = Math.max(maxRowLen, itemRow.length)

        let row_idx = 1
        for (let itemRow of itemFormat) {
            let col_idx = 1
            for (let itemName of itemRow) {
                let item_id = namedItemList[itemName]
                add_item_to_grid(item_id, col_idx++, row_idx)
            }
            row_idx++
        }
        calcCurrGridItems()
    }

    function calcCurrGridItems() { // save the current item grid
        while (currGridItems.length > 0)
            currGridItems.pop()
        
        let gridLoc = {}
        // These could be in any order. I need to find min/max then build that
        let max_row = 0
        let max_col = 0
        let item_ref = {}
        for (let el of itemGridDiv.children) {
            if (el.getAttribute('item_id') != null) {
                let el_row = el.style.getPropertyValue('grid-row')
                el_row = parseInt(el_row.substring(0, el_row.indexOf('/')))-1
                let el_col = el.style.getPropertyValue('grid-column')
                el_col = parseInt(el_col.substring(0, el_col.indexOf('/')))-1

                max_row = Math.max(el_row, max_row)
                max_col = Math.max(el_col, max_col)
                item_ref[`${el_col},${el_row}`] = el.getAttribute('item_id')
            }
        }

        for (let row=0; row <= max_row; row++) {
            let new_row = [...Array(max_col+1).keys()] // ? way to max Array of length X
            new_row.fill(null, 0, max_col+1)
            currGridItems.push(new_row)
        }

        for (let el_pos in item_ref) {
            let el_loc = el_pos.split(',')
            currGridItems[parseInt(el_loc[1])][parseInt(el_loc[0])] = 
                keyItemList[item_ref[el_pos]].name
        }
    }

    function add_item_to_grid(item_id, col=null, row=null) {
        // Add item to grid
        let imgEl = document.createElement('img')
        if (item_id) { // Add img tile to the grid
            imgEl = createItemImg(item_id)
            let item_name = keyItemList[item_id]
            imgEl.classList.add('transparent')

            itemGridDiv.appendChild(imgEl)
            gridImgLink[item_name] = imgEl
            imgEl.addEventListener('dragstart', item_dragstart_handler)
            imgEl.addEventListener('dragend', item_dragend_handler)
        } else { // Add a blank tile that accepts drop events
            imgEl = document.createElement('div')
            imgEl.setAttribute('draggable', false)
            imgEl.classList.add('itemImage', 'blank')
            
            itemGridDiv.appendChild(imgEl)
        }
        
        if (col != null)    imgEl.style.setProperty('grid-column', col)
        if (row != null)    imgEl.style.setProperty('grid-row', row)

        imgEl.addEventListener('dragleave', item_dragleave_handler)
        imgEl.addEventListener('dragover', item_dragover_handler)
        imgEl.addEventListener('drop', item_drop_handler)
    }

    function item_dragstart_handler(ev) {
        // Add the target element's id to the data transfer object
        ev.dataTransfer.setData("text/plain", ev.target.getAttribute('item_id'));
        ev.dataTransfer.setData("application/el", ev.target);
        ev.dataTransfer.dropEffect = "move";
        ev.dataTransfer.setDragImage(ev.target, 10, 10)
        
        dragTarget = ev.target
        dragTarget.classList.add('dragging')
    }

    function item_dragend_handler(ev) {
        dragTarget.classList.remove('dragging')
        dragTarget = null
    }

    function item_dragover_handler(ev) { // This is necessary
        ev.preventDefault();
        // TODO: Anything that isnt an item, ignore
        ev.dataTransfer.dropEffect = "move";
        ev.target.classList.add('dragover')
    }

    function item_dragleave_handler(ev) { // Reset the 
        ev.preventDefault();
        ev.dataTransfer.dropEffect = "move";
        ev.target.classList.remove('dragover')
    }

    function item_drop_handler(ev) {
        // Move the new item to this location
        ev.preventDefault();
        const item_id = ev.dataTransfer.getData("text/plain");

        const targetEl = ev.target
        let tarLoc = [targetEl.style.getPropertyValue('grid-column'),
                        targetEl.style.getPropertyValue('grid-row')]
        console.log(`Moving ${item_id} to (${tarLoc})`)
        // Delete old element
        const currEl = dragTarget
        let dragLoc = [currEl.style.getPropertyValue('grid-column'),
                        currEl.style.getPropertyValue('grid-row')]

        if (currEl.parentElement == targetEl.parentElement) {
            // both in itemGrid, swap locations
            targetEl.style.setProperty('grid-column', dragLoc[0])
            targetEl.style.setProperty('grid-row', dragLoc[1])

            // Move currEl over here
            currEl.style.setProperty('grid-column', tarLoc[0])
            currEl.style.setProperty('grid-row', tarLoc[1])
        } else {
            // If drag element isn't in grid, create new image at target location
            add_item_to_grid(item_id, tarLoc[0], tarLoc[1])
            // then delete old item
            const targetElParent = targetEl.parentElement
            targetElParent.removeChild(targetEl)
            delete targetEl
        }

        ev.target.classList.remove('dragover')
        
    }


    // ------------------------------------------------------------------------
    // SAVE-FILE HANDLERS
    // ------------------------------------------------------------------------

    const profileSize = 0x060030;
    const AES_KEY_BYTES = Uint8Array.from([0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10]).buffer;
    const AES_IV_BLOCKLEN = 16; // 16 bytes
    let AES_Crypto_Key = null;
    let AES_Crypto_Promise = null; // Doing the crypto promise/etc once DSR save file is determined

    const dropZone = document.querySelector('.dropZone')
    dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = "link";
    })
    dropZone.addEventListener('drop', async event => {
        event.preventDefault();
        
        if (event.dataTransfer.items) {
            for (let file of event.dataTransfer.items) {
                if (file.kind === 'file') {
                    fileHandle = await file.getAsFileSystemHandle();
                    loadSaveFile(fileHandle)
                    break
                }
            }
        }
    })

    // TODO: Do some dragenter/dragdrop/blur styling in the future

    //TODO: Too many async / awaits in this chain
    document.querySelector('.dropZone').addEventListener('dblclick', async() => {
        infoBox.textContent = "Checking";
        [fileHandle] = await window.showOpenFilePicker() //TODO: add restrictions to file type
        //TODO: Handle if the file is not valid & request is cancelled
        loadSaveFile(fileHandle)
    })

    if (!window.showOpenFilePicker)
        infoBox.textContent = "File System API not supported :( \n Please use latest version of Chrome";

    async function loadSaveFile (fileHandle) {
        // Load file & fileHandle
        actualFile = await fileHandle.getFile()
        document.querySelector('#steps').classList.add('min')

        if (await actualFile.slice(0, 4).text() == 'BND4') {
            if (!spkID)
                setUpSpeaker()
            readBND4File(actualFile) 
            updateFileProperties(actualFile)

            // Start polling of the file 
            clearInterval(filePollTimeout)
            filePollTimeout = setInterval( async () => {
                // poll file change every few seconds
                if (! (await checkFileValid(actualFile)) ) {
                    actualFile = await fileHandle.getFile()
                    readBND4File(actualFile)
                }
                updateFileProperties(actualFile)
            }, filePollTime)
        } else {
            console.error('This is not a valid BND4 file')
            infoBox.textContent = "This doesn't appear to be a DS1 Save File"
        }
    }

    async function checkFileValid (file) {
        try {
            let filetext = await file.slice(0, 1).text() // 1 byte
        } catch (exception) {
            return false // File is not readable due to on-disk modification, reload fileHandle
        }
        return true
    }

    function updateFileProperties (file) {
        // takes File NOT FileHandle
        fileName.textContent = actualFile.name
        fileLastUpdated.textContent =  `${parseToTimeElapsed(Date.now() - actualFile.lastModified)}ago`
    }

    function parseToTimeElapsed (ms) {
        let timestr = ""
        const sec = 1000
        const min = sec * 60
        const hr = min * 60
        const day = hr * 24
        if (ms > day) {
            timestr += `${Math.floor(ms/day)}d `
            ms = ms % day
        }
        if (ms > hr) {
            timestr += `${Math.floor(ms/hr)}h `
            ms = ms % hr
        }
        if (ms > min) {
            timestr += `${Math.floor(ms/min)}m `
            ms = ms % min
        }
        if (ms > sec) {
            timestr += `${Math.floor(ms/sec)}s `
            ms = ms % sec
        }
        return timestr
    }

    //TODO: convert to Readable Stream, maybe faster?
    async function readBND4File (file) {
        // Adapted from gabtoubl's js port

        let b_idx = 0;
        skipBytes = (bytes) => b_idx += bytes
        read = (start, bytes) => file.slice(start, bytes)

        let format = await file.slice(0, 4).text() // format at position 0, UTF-8
        if (format != 'BND4') {
            console.warn('Not a valid DS1 save file, missing BND4 tag')
            return
            // TODO: Display warning in GUI
        }

        b_idx = 0x18; // version offset
        let version = await file.slice(b_idx, b_idx+8).text()
        console.log(`version: ${version}`)

        if (version == '00000001') {
            console.info('Appears to be a DS1:PTDE save file')
            DSPTE_ReadMode = true;
        } else if (version == '\0\0\0\0\0\0\0\0') { //DSR has null data where the version no. is
            console.info('Appears to be a DS1:R save file')
            if (window.crypto && window.crypto.subtle) { // Generating a key via a promise
                AES_Crypto_Promise = window.crypto.subtle.importKey('raw', AES_KEY_BYTES, {'name':'AES-CBC'}, false, ['decrypt'])
                console.info('Starting up AES decryption')
            } else { 
                console.warn('This browser does not support the crypto module; please update!') //It was released in 2014, what you doing
                return
            }
            DSPTE_ReadMode = false;
        }

        b_idx = 0x50; // container header data starts at 0x40, going straight to the start offset at 0x50
        profileStartOffset = []
        // Capture player/profile offsets
        for (let i=0; i<11; i++) {
            profileStartOffset.push( new Uint32Array(await file.slice(b_idx, b_idx+4).arrayBuffer())[0] ); // convert to int (use int8array)
            b_idx += 32; // containers are 32 bytes high/long
        }
        // 11th header is for grabbing some additional stuff
        // console.log(profileStartOffset)

        oldPlayers = players
        players = []

        // Start reading player/profiles
        // TODO: Change performance data to use measure & etc
        // TODO: Need to rewrite the async logic SO player parse is parallel & has early out
        let pt = performance.now()
        for (let i=0; i<10; i++) {
            let savedPlayer = null;
            if (version == '00000001') {
                let p1 = performance.now()
                savedPlayer = await readPlayerData(file.slice(profileStartOffset[i], profileStartOffset[i]+profileSize))
                console.log(`DS1 player took ${performance.now() - p1}`)
            } else {
                let p2 = performance.now()
                let saveSlotBlob = file.slice(profileStartOffset[i], profileStartOffset[i]+profileSize)
                let saveSlotPromise = saveSlotBlob.slice(AES_IV_BLOCKLEN).arrayBuffer()
                let profile_IV = await saveSlotBlob.slice(0, AES_IV_BLOCKLEN).arrayBuffer()

                AES_Crypto_Key = (!AES_Crypto_Key) ? await AES_Crypto_Promise : AES_Crypto_Key

                let saveSlotData = new Uint8Array(await saveSlotPromise)
                let decryptSaveSlotBuffer = await window.crypto.subtle.decrypt( {name: 'AES-CBC', iv: profile_IV}, AES_Crypto_Key, saveSlotData)

                let decryptSaveSlotBlob = new Blob([decryptSaveSlotBuffer])
                console.log(`DSR player decrypt ${performance.now() - p2}ms`)

                savedPlayer = await readPlayerData(decryptSaveSlotBlob.slice(8)) // For some reason, this is offset by 8 bytes.
                console.log(`DSR player took ${performance.now() - p2}ms`)
            }
            // if (!savedPlayer) break //cant early exit if empty slots are first
        }
        console.log(`All players took ${performance.now() - pt}ms`, players)

        // Now lets compare the hashes and see if there was a change
        calculatePlayerDiff()

        // send update and let client figure out
        fetchIDPromise.then(() => {
        // if (spkID) {
            fetch(`${baseUrl}/speakMic`, 
                {method: 'POST', mode: 'cors', cache: 'no-cache', 
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({'spkID': spkID, 'player': trackedPlayer})}
            )
            keepAliveTs = Date.now()
            console.log("Updated Save-Data")
        })
        // NOTE: I could compress & only send diffs, but its ~ 500B which is nothing
    }

    async function readPlayerData(file) {
        let p = performance.now()

        let playerHeaderBuffer = await file.slice(0, 0x170).arrayBuffer() // read player data from the blob
        let player = {}
        player.headerHash = 0
        player.level = new Uint32Array(playerHeaderBuffer, 0xE8, 1)[0];
        if (player.level == 0) {
            console.warn('Level 0 player detected')
            return false //TODO: Should skip this unless its a good trigger
        }
        
        player.souls = new Uint32Array(playerHeaderBuffer, 0xec, 1)[0];
        player.name8 = String.fromCharCode(...new Uint16Array(playerHeaderBuffer, 0x100, 14)) // name via UTF-16
        
        // gotta check for null-chars cause of C-strings
        let nullCharIdx = player.name8.indexOf(String.fromCharCode(0))
        player.name = (nullCharIdx > 0) ? player.name8.substring(0, nullCharIdx) : player.name8 // assuming name is not null here
        players.push(player)

        // simple hash for player comparison NOTE: None of this is unique, I don't know what values to use to verify.
        player.headerHash = player.name + String.fromCharCode(player.souls >> 16, player.souls & 0xFFFF, player.level, )

        console.log(`player ${player.name} computed header in ${performance.now()-p}ms`)

        // Read item list
        const backpackOffset = DSPTE_ReadMode ? 0x2E0 : 0x2F8   // Note DSR seems to be offset by 24 bytes
        const backpackEndOffset = DSPTE_ReadMode ? 0xE2E0 : 0xE2F8
        player.items = {}
        player.keyItems = []
        player.itemHash = ''
        p = performance.now()
        let backpackArrayBuffer = (await file.slice(backpackOffset, backpackOffset + backpackEndOffset).arrayBuffer())

        for (let item_idx = 0; item_idx + backpackOffset < backpackEndOffset; item_idx += 4*7) {
            let item = {}
            let id = new Uint32Array(backpackArrayBuffer, item_idx+4, 1)[0]
            // TODO: After ~100 0xFFFFFFFF item ids I should quit the item check, however item check completes in <10ms on my machine
            // so skipping ~400 items might not save much time

            if (true && id < 0xFFFFFFFF) { // empty slots have MAX_32_INT value
                if (keyItemList[id]) {
                    item.name = keyItemList[id].name // only key item list lookup
                    if (id == 190000 || id == 1396000)
                        player.keyItems.push("Light Source")
                    else 
                        player.keyItems.push(keyItemList[id].name) // set value for diffs later
                }
                // there can be the same item in 2 slots but IDK
                item.amount = new Uint32Array(backpackArrayBuffer, item_idx+8, 1)[0]
                // NOTE: I don't care about item type but note item ids are not unique 
                item.have = (0 != new Uint32Array(backpackArrayBuffer, item_idx + 16, 1)[0]) // convert to boolean
                player.items[id] = item
                player.itemHash += String.fromCharCode(id, item.amount, item.have)
            }
        }

        console.log(`player ${player.name} computed items in ${performance.now()-p}ms`)
        return true
    }

    function calculatePlayerDiff() {

        if (!players.length) {
            infoBox.textContent = 'No players found'
            return
        }

        // Diff player data with latest parsed data
        let playerStats = []
        for (let player of players) {
            // playerStats.push(`${player.name}: \tLv. ${player.level} \t| ${player.souls} souls \t| ${Object.keys(player.items).length} items `)
            playerStats.push(`<tr><td>${player.name}</td> <td>${player.level}</td><td>${player.souls} souls</td> <td>${Object.keys(player.items).length} items </td>`)
        }

        /*
            null        -> nothing
            players     -> display player stats + trackLastPlayer
            old + players -> show stats + trackUpdated player
        */

        let nTrackedPlayer = null
        if (oldPlayers) {
            for (let i=0; i<players.length; i++) {
                if (oldPlayers[i] && oldPlayers[i].name == players[i].name) {
                    playerStats[i] += '<td>F</td>'
                    
                    if (oldPlayers[i].headerHash != players[i].headerHash) {
                        playerStats[i] += '<td>H</td>'
                        nTrackedPlayer = players[i]
                    }
                    if (oldPlayers[i].itemHash != players[i].itemHash) {
                        playerStats[i] += '<td>I</td>'
                        nTrackedPlayer = players[i]
                    }
                }
                playerStats[i] += '</tr>'
            }
        }
        
        infoBox.innerHTML = `<table> <thead><th>Name</th> <th>Level</th> <th>Souls</th> <th>Items</th> <th>Track</th></thead>
            ${playerStats.join('\n')} </table><br/>`

        nTrackedPlayer = nTrackedPlayer || players[players.length-1]

        //nTrackedPlayer either last changed or last new
        if (trackedPlayer && trackedPlayer.name == nTrackedPlayer.name) { // verify its the same player
            // infoBox.innerHTML += `Tracking ${nTrackedPlayer.name} ...\n`
            infoState.textContent = `Tracking ${nTrackedPlayer.name}`
        } else {
            trackedPlayer = null // reset tracked player, causes intersect to do a catch-up
            // infoBox.innerHTML += `Watching ${nTrackedPlayer.name}`
            infoState.textContent = `Watching ${nTrackedPlayer.name} (waiting for save file update)`
        }

        // do set intersect
        let initKeyItems = (trackedPlayer && trackedPlayer.keyItems) || []
        let keyItemIntersect = nTrackedPlayer.keyItems.filter(ki => !initKeyItems.includes(ki))

        for (let imgLink in gridImgLink) {
            if (nTrackedPlayer.keyItems.includes(imgLink))
                gridImgLink[imgLink].classList.remove('transparent')
            else
                gridImgLink[imgLink].classList.add('transparent')
        }

        trackedPlayer = nTrackedPlayer
    }



</script>
</html>